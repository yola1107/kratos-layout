// Code generated by protoc-gen-go-tcp. DO NOT EDIT.
// versions:
// - protoc-gen-go-tcp v2.8.3
// - protoc            v3.6.1
// source: helloworld/v1/greeter.proto

package v1

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
import (
	"context"

	"github.com/yola1107/kratos/v2/log"
	"github.com/yola1107/kratos/v2/transport/tcp"

	"github.com/gogo/protobuf/proto"
)

var (
	ins *Loop
)

type Loop struct {
	jobs   chan func()
	toggle chan byte
}

func RecoverFromError(cb func()) {
	if e := recover(); e != nil {
		log.Error("Recover => %s:%s\n", e, debug.Stack())
		if nil != cb {
			cb()
		}
	}
}
func (lp *Loop) Start() {
	log.Info("loop routine start.")
	go func() {
		defer RecoverFromError(func() {
			lp.Start()
		})
		for {
			select {
			case <-lp.toggle:
				log.Info("Loop routine stop.")
				return
			case job := <-lp.jobs:
				job()
			}
		}
	}()
}
func (lp *Loop) Stop() {
	go func() {
		lp.toggle <- 1
	}()
}
func Stop() { ins.Stop() }
func (lp *Loop) Jobs() int {
	return len(lp.jobs)
}
func Jobs() int { return ins.Jobs() }
func (lp *Loop) Post(job func()) {
	go func() {
		lp.jobs <- job
	}()
}
func Post(job func()) { ins.Post(job) }
func (lp *Loop) PostAndWait(job func() interface{}) interface{} {
	ch := make(chan interface{})
	go func() {
		lp.jobs <- func() {
			ch <- job()
		}
	}()
	return <-ch
}
func PostAndWait(job func() interface{}) interface{} { return ins.PostAndWait(job) }

// GreeterTcpServer is the server API for Greeter service.
type GreeterTCPServer interface {
	SetCometChan(cl *tcp.ChanList, cs *tcp.Server)
	IsLoopFunc(f string) (isLoop bool)
	SayHello(context.Context, *HelloRequest) (*HelloReply, error)
	SayHello2(context.Context, *Hello2Request) (*Hello2Reply, error)
}

func RegisterGreeterTCPServer(s *tcp.Server, srv GreeterTCPServer) {
	s.RegisterService(&Greeter_TCP_ServiceDesc, srv)
	chanList := s.RegisterService(&Greeter_TCP_ServiceDesc, srv)
	srv.SetCometChan(chanList, s)
	ins = &Loop{jobs: make(chan func(), 10000), toggle: make(chan byte)}
	ins.Start()
}

func _Greeter_SayHello_TCP_Handler(srv interface{}, ctx context.Context, data []byte, interceptor tcp.UnaryServerInterceptor) ([]byte, error) {
	in := new(HelloRequest)
	err := proto.Unmarshal(data, in)
	if err != nil {
		return nil, err
	}
	if interceptor == nil {
		out, err := srv.(GreeterTCPServer).SayHello(ctx, in)
		data, _ := proto.Marshal(out)
		return data, err
	}
	info := &tcp.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/_Greeter_SayHello_TCP_Handler/SayHello",
	}
	handler := func(ctx context.Context, req interface{}) ([]byte, error) {
		out := new(HelloReply)
		var err error
		if srv.(GreeterTCPServer).IsLoopFunc("SayHello") {
			rspChan := make(chan *HelloReply)
			errChan := make(chan error)
			ins.Post(func() {
				resp, err := srv.(GreeterTCPServer).SayHello(ctx, req.(*HelloRequest))
				rspChan <- resp
				errChan <- err
			})
			out = <-rspChan
			err = <-errChan
		} else {
			out, err = srv.(GreeterTCPServer).SayHello(ctx, req.(*HelloRequest))
		}
		if out != nil {
			data, _ := proto.Marshal(out)
			return data, err
		}
		return nil, err
	}
	return interceptor(ctx, in, info, handler)
}
func _Greeter_SayHello2_TCP_Handler(srv interface{}, ctx context.Context, data []byte, interceptor tcp.UnaryServerInterceptor) ([]byte, error) {
	in := new(Hello2Request)
	err := proto.Unmarshal(data, in)
	if err != nil {
		return nil, err
	}
	if interceptor == nil {
		out, err := srv.(GreeterTCPServer).SayHello2(ctx, in)
		data, _ := proto.Marshal(out)
		return data, err
	}
	info := &tcp.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/_Greeter_SayHello2_TCP_Handler/SayHello2",
	}
	handler := func(ctx context.Context, req interface{}) ([]byte, error) {
		out := new(Hello2Reply)
		var err error
		if srv.(GreeterTCPServer).IsLoopFunc("SayHello2") {
			rspChan := make(chan *Hello2Reply)
			errChan := make(chan error)
			ins.Post(func() {
				resp, err := srv.(GreeterTCPServer).SayHello2(ctx, req.(*Hello2Request))
				rspChan <- resp
				errChan <- err
			})
			out = <-rspChan
			err = <-errChan
		} else {
			out, err = srv.(GreeterTCPServer).SayHello2(ctx, req.(*Hello2Request))
		}
		if out != nil {
			data, _ := proto.Marshal(out)
			return data, err
		}
		return nil, err
	}
	return interceptor(ctx, in, info, handler)
}

var Greeter_TCP_ServiceDesc = tcp.ServiceDesc{
	ServiceName: "helloworld.v1.Greeter",
	HandlerType: (*GreeterTCPServer)(nil),
	Methods: []tcp.MethodDesc{
		{
			MethodName: "SayHello",
			Handler:    _Greeter_SayHello_TCP_Handler,
			Ops:        1001,
		},
		{
			MethodName: "SayHello2",
			Handler:    _Greeter_SayHello2_TCP_Handler,
			Ops:        1003,
		},
	},
}
